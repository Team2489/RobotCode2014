// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "TurnAngle.h"
TurnAngle::TurnAngle(double angle, double tolrence, double delta, double zone, double compensation, double timeout):
    PIDCommand("TurnRightAngle", 1.0, 0, 0, 0.01)
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	Requires(CommandBase::chassis);
	m_angle = angle/180.0 *compensation;
//	cout << "TR: m_angle: " << m_angle << endl;
	GetPIDController()->SetTolerance(tolrence);
	GetPIDController()->SetContinuous(false);
	m_delta = delta;
	m_zone_lower = zone;
	m_zone_higher = 0.5;
	m_finished = 0;
	m_time = timeout;
	//GetPIDController()->SetOutputRange(0.2, 1.0);	
}
double TurnAngle::ReturnPIDInput() {
	double input = CommandBase::chassis->m_gyro->PIDGet();
//	cout << "input: " << input << endl;  
	return input;
}
void  TurnAngle::UsePIDOutput(double output) {
//	cout << "output: " << output << endl;
	if (output > 0) {
		output = output + m_zone_lower;
		if (output > m_zone_higher) {
			output = m_zone_higher;			
		}
	} else {
		output = output - m_zone_lower;
		if (output < -m_zone_higher) {
			output = -m_zone_higher;
		}
	}
//	cout << "real output: " << output << endl;
	CommandBase::chassis->m_leftMotor->PIDWrite(output);
	CommandBase::chassis->m_rightMotor->PIDWrite(output);
}
void TurnAngle::SetAngle(double angle)
{
	m_angle = angle/180.0;
}
// Called just before this Command runs the first time
void TurnAngle::Initialize() {
	// m_angle == 0: we disabled
	if (m_angle == 0) {
		return;
	}
//	cout << "TR: Intialized, m_angle: " << m_angle <<  endl;
//	cout << "TR: Intialized Setpoint: " << GetSetpoint() << " Position: " << GetPosition()<< endl;
	SetSetpoint(ReturnPIDInput() + m_angle);
	if(m_time != 0){
		SetTimeout(m_time);
	}
//	cout << "TR: Intialized2 Setpoint: " << GetSetpoint() << " Position: " << GetPosition()<< endl;
}
// Called repeatedly when this Command is scheduled to run
void TurnAngle::Execute() {
}
// Make this return true when this Command no longer needs to run execute()
bool TurnAngle::IsFinished() {
	// m_angle == 0: we disabled
	if (m_angle == 0) {
		return true;
	}
	double delta = GetSetpoint() - GetPosition();
	// double delta = 1.0;
	if(delta < 0){
		delta = -delta;
	}
	//cout << "TR: IsFinished Setpoint4: " << GetSetpoint() << " Position: " << GetPosition() <<" delta: " << delta << endl;
	if(delta < m_delta){
		//cout << "TR: IsFinished Setpoint3: " << GetSetpoint() << " Position: " << GetPosition() << endl;
		m_finished++;
	} else {
		m_finished = 0;		
	}
	
	if (m_finished > 20) {
		//cout << "TR: IsFinished Setpoint2: " << GetSetpoint() << " Position: " << GetPosition() << endl;
		return true;
	}
	if(m_time != 0){
		return IsTimedOut();
	}
	return false;
}
// Called once after isFinished returns true
void TurnAngle::End() {
	//cout << "TR: End Setpoint: " << GetSetpoint() << " Position: " << GetPosition() << endl;
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TurnAngle::Interrupted() {
	cout << "TR: Interrupted Setpoint: " << GetSetpoint() << " Position: " << GetPosition() << endl;
}
